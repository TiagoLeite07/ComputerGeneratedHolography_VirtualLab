<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Computer Generated Holography Virtual Lab</title>
    <link rel="stylesheet" href="css/base.css" />
</head>
<body>
    <div id="container"></div>

    <script src="js/three.min.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/gui/stats.min.js"></script>
    <script src="js/Mirror.js"></script>
    <script src="js/gui/dat.gui.js"></script>
    <script src="js/csg.js"></script>
    <script src="js/ThreeCSG.js"></script>
    <script src="js/CGHLab.js"></script>
    <script src="js/scenes/main/mainPerspective.js"></script>
    <script src="js/geometry/HoloObject.js"></script>
    <script src="js/holography/LightPoint.js"></script>
    <script src="js/holography/Wave.js"></script>
    <script src="js/holography/HologramShaderLib.js"></script>
    <script>
        if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

        var mainPerspective, camera, controls, renderer, cubescene, spherescene;
        var container, stats;
        var gui = new dat.GUI();
        var currentPerspective;
        var laserTurnOn = false;

        var rayCaster;
        var mouse = new THREE.Vector2(), INTERSECTED, SELECTED;

        init();

        animate();

        function init() {
            container = document.getElementById('container');

            ////RENDERER
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setClearColor(0x777777);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = true;

            container.appendChild(renderer.domElement);

            ////CAMERA
            var aspect = window.innerWidth / window.innerHeight;

            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 10000);
            camera.position.set(0, 30, 0);

            ////SCENES
            cubescene = new THREE.Scene();
            spherescene = new THREE.Scene();
            mainPerspective = new CGHLab.MainPerspective(renderer, camera);

            ////CONTROLS
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.target = new THREE.Vector3(0,0,0);

            /*------------------------------------------------------------------------------*/
            ////GEOMETRY
            mainPerspective.init();
            controls.target = mainPerspective.getCenter();

            //CUBE SCENE
            var cubegeometry2 = new THREE.BoxGeometry(1, 1, 1);
            var cubematerial2 = new THREE.MeshPhongMaterial({ color: 0x00ffff });
            var cube2 = new THREE.Mesh(cubegeometry2, cubematerial2);
            cube2.scale.set(3,3,3);
            cubescene.add(cube2);

            var axes = new THREE.AxisHelper(10);
            cubescene.add( axes );

            //SPHERE SCENE
            var spheregeometry2 = new THREE.SphereGeometry(1, 32, 32);
            var spherematerial2 = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            var sphere2 = new THREE.Mesh(spheregeometry2, spherematerial2);
            sphere2.position.set(5,0,0);
            spherescene.add(sphere2);

            var axes2 = new THREE.AxisHelper(10);
            spherescene.add( axes2 );

            ////LIGHTS
            //CUBE SCENE
            var amblight2 = new THREE.AmbientLight( 0x505050 );
            var light2 = new THREE.PointLight( 0xffffff, 1);
            light2.position.set( 10, 10, 10 );
            cubescene.add( amblight2 );
            cubescene.add( light2 );

            //SPHERE SCENE
            var amblight3 = new THREE.AmbientLight( 0x505050 );
            var light3 = new THREE.PointLight( 0xffffff, 1);
            light3.position.set( 10, 10, 10 );
            spherescene.add( amblight3 );
            spherescene.add( light3 );

            /*---------------------------------------------------------------------------*/

            ////RAYCASTING
            rayCaster = new THREE.Raycaster();

            ////FPS COUNTER
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            container.appendChild( stats.domElement );

            ////GUI
            setGUI('main');

            currentPerspective = 'main';

            ////CALLBACKS
            window.addEventListener( 'resize', onWindowResize, false );
            window.addEventListener( 'mousemove', onDocumentMouseMove, false );
            window.addEventListener( 'mousedown', onDocumentMouseDown, false );
        }

        function setGUI( perspective )
        {
            var parameters;
            gui.destroy();
            if(perspective == 'main')
            {
                gui = new dat.GUI();

                parameters =
                {
                    laserOn: function(){if (!laserTurnOn) mainPerspective.laserOn(); laserTurnOn = true;},
                    laserOff: function(){if (laserTurnOn) mainPerspective.laserOff(); laserTurnOn = false;},
                    objectRotationSlider: 0,
                    focusCenter: function(){controls.target = mainPerspective.getCenter()},
                    geometry: 'cube',
                    interferencePattern: function(){ mainPerspective.seeInterferencePattern(); }
                };

                /*var cubeRotation = gui.add(parameters, 'cubeRotation').min(0).listen();
                cubeRotation.onChange(function(value){
                    mainPerspective.updateObjectRotation(value)
                });*/

                gui.add(parameters, 'laserOn').name('Turn On Laser');
                gui.add(parameters, 'laserOff').name('Turn Off Laser');
                gui.add(parameters, 'focusCenter').name('Focus Center');
                gui.add(parameters, 'interferencePattern').name('See Interference Pattern');

                var folder1 = gui.addFolder('Object');
                var r = folder1.add( parameters, 'objectRotationSlider').min(0).max(360).name('Rotation');
                r.onChange(function(value){
                    mainPerspective.rotateObject(value);
                });
                var geometry = folder1.add( parameters, 'geometry', [ 'cube', 'sphere', 'octahedron', 'tetrahedron' ] ).name('Geometry').listen();
                geometry.onChange(function(value)
                {
                    mainPerspective.object.changeObject(value);
                });
                folder1.open();
                gui.open();
            }
            else if(perspective == 'object')
            {
                gui = new dat.GUI();

                parameters =
                {
                    a: 200, // numeric
                    b: 200, // numeric slider
                    c: "Hello, GUI!", // string
                    d: false // boolean (checkbox)
                };
                // gui.add( parameters )
                gui.add( parameters, 'a' ).name('Number');
                gui.add( parameters, 'b' ).min(128).max(256).step(16).name('Slider');
                gui.add( parameters, 'c' ).name('String');
                gui.add( parameters, 'd' ).name('Boolean');

                gui.open();
            }
            else if(perspective == 'plate')
            {
                gui = new dat.GUI();

                parameters =
                {
                    e: "#ff8800", // color (hex)
                    f: function() { alert("Hello!") },
                    g: function() { alert( parameters.c ) },
                    v : 0,    // dummy value, only type is important
                    w: "...", // dummy value, only type is important
                    x: 0, y: 0, z: 0
                };
                // gui.add( parameters )

                gui.addColor( parameters, 'e' ).name('Color');

                var numberList = [1, 2, 3];
                gui.add( parameters, 'v', numberList ).name('List');

                var stringList = ["One", "Two", "Three"];
                gui.add( parameters, 'w', stringList ).name('List');

                gui.add( parameters, 'f' ).name('Say "Hello!"');
                gui.add( parameters, 'g' ).name("Alert Message");

                var folder2 = gui.addFolder('Coordinates');
                folder2.add( parameters, 'x' );
                folder2.add( parameters, 'y' );
                folder2.close();
                gui.open();
            }
        }

        function onWindowResize()
        {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function onDocumentMouseDown( event )
        {
            //event.preventDefault(); //Makes dat.GUI not work properly

            camera.updateMatrixWorld();

            rayCaster.setFromCamera( mouse, camera );

            var intersects = rayCaster.intersectObjects( mainPerspective.objects );

            if ( intersects.length > 0 ) {

                SELECTED = intersects[ 0 ].object;

                controls.target = SELECTED.position;

            }
        }

        function onDocumentMouseMove( event )
        {
            //event.preventDefault(); //Makes dat.GUI not work properly

            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function animate()
        {
            requestAnimationFrame( animate );
            render();
            update();
        }

        function render()
        {
            camera.updateMatrixWorld();

            rayCaster.setFromCamera( mouse, camera );

            var intersects = rayCaster.intersectObjects( mainPerspective.objects );

            if ( intersects.length > 0 ) {

                /*if ( INTERSECTED != intersects[ 0 ].object ) {

                    if ( INTERSECTED ) INTERSECTED.material.uniforms.emissive.value.setHex( INTERSECTED.currentHex );

                    INTERSECTED = intersects[ 0 ].object;
                    //alert('x-'+INTERSECTED.position.x+' y-'+INTERSECTED.position.y+' z-'+INTERSECTED.position.z);
                    INTERSECTED.currentHex = INTERSECTED.material.uniforms.emissive.value.getHex();
                    INTERSECTED.material.uniforms.emissive.value.setHex(0xff0000);

                }*/

                container.style.cursor = 'pointer';

            } else {

                /*if ( INTERSECTED ) alert(INTERSECTED.name);//INTERSECTED.material.uniforms.emissive.value.setHex( INTERSECTED.currentHex );

                INTERSECTED = null;*/

                container.style.cursor = 'auto';

            }

            if(SELECTED)
            {
                if(SELECTED.position.distanceTo(camera.position) < 10)
                {
                    if(SELECTED.name == 'object') {
                        if (currentPerspective != 'object')
                        {
                            currentPerspective = 'object';
                            setGUI('object');
                        }
                        renderer.render(cubescene, camera);
                    }
                    else if(SELECTED.name == 'plate')
                    {
                        if (currentPerspective != 'plate')
                        {
                            currentPerspective = 'plate';
                            setGUI('plate');
                        }
                        renderer.render(spherescene, camera);
                    }
                }
                else
                {
                    if(currentPerspective != 'main')
                    {
                        currentPerspective = 'main';
                        setGUI('main');
                    }
                    mainPerspective.mirror.render();
                    renderer.render(mainPerspective.scene, camera);
                }
            }
            else
            {
                mainPerspective.mirror.render();
                renderer.render(mainPerspective.scene, camera);
            }
        }

        function update()
        {
            controls.update();
            stats.update();
            if (laserTurnOn) mainPerspective.updateLaser();
        }
    </script>
</body>
</html>